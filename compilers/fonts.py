import fontforge, sys
from pathlib import Path
from PIL import Image, ImageDraw
import os


def dump_glyphs(ttf_path, out_dir, min_ch=32, max_ch=126):
    font = fontforge.open(ttf_path)
    os.makedirs(out_dir, exist_ok=True)

    for code in range(min_ch, max_ch + 1):
        glyph: fontforge.glyph = font[code]
        glyph.export(f'{out_dir}/{code:02x}.png')


def process_glyphs(a, b, height = 25, skip=0.1, threshold=128):
    os.makedirs(b, exist_ok=True)
    for file in os.listdir(a):
        if file.lower().endswith(".png"):
            img = Image.open(os.path.join(a, file))
            w, h = img.size
            pixels = img.load()

            white_top = 0
            while white_top < h:
                if not all(pixels[x, white_top] > 250 for x in range(w)):
                    break
                white_top += 1
            white_bottom = 0
            while white_bottom > 0:
                if not all(pixels[x, h - 1 - white_bottom] > 250 for x in range(w)):
                    break
                white_bottom -= 1
            skip_target = int(h * skip)
            skip_top = 0
            skip_bottom = 0
            while skip_top + skip_bottom < skip_target:
                if skip_top < white_top:
                    skip_top += 1
                    break
                elif skip_bottom < white_bottom:
                    skip_bottom += 1
                else:
                    break

            img = img.crop((0, skip_top, w, h - skip_bottom))
            img = img.resize((w * height // h, height), Image.LANCZOS)
            img = img.convert("1", dither=Image.FLOYDSTEINBERG)
            #img = img.point(lambda p: 255 if p < threshold else 0, mode="1")
            img.save(os.path.join(b, file))


def encode_font(png_dir, out_file, min_ch=32, max_ch=126):
    png_dir = Path(png_dir)
    font_bytes = bytearray()
    offsets = []
    widths = []
    height = None

    for code in range(min_ch, max_ch + 1):
        png_path = png_dir / f"{code:02x}.png"
        if not png_path.exists():
            raise FileNotFoundError(f"Missing glyph PNG for U+{code:02x})")

        img = Image.open(png_path).convert("1")
        w, h = img.size
        if height is None:
            height = h
        elif h != height:
            raise ValueError(f"Inconsistent height: {png_path} has {h} expected {height}")

        widths.append(w)
        offsets.append(len(font_bytes))

        # width header (2 bytes little-endian)
        font_bytes += int(w).to_bytes(2, "little")

        # bytes per row (guaranteed)
        row_bytes = (w + 7) // 8
        pixels = img.load()

        # For each row produce exactly row_bytes bytes.
        # Bit order: MSB first in each byte (bit 7 = leftmost pixel).
        for y in range(h):
            for byte_i in range(row_bytes):
                b = 0
                base_x = byte_i * 8
                for bit in range(8):
                    x = base_x + bit
                    if x >= w:
                        # past glyph width -> pad with zero
                        continue
                    if pixels[x, y] == 0:
                        b |= 1 << (7 - bit)
                font_bytes.append(b)

    offsets.append(len(font_bytes))  # final end offset

    # build index table (2 bytes per entry little-endian)
    index_bytes = bytearray()
    for off in offsets:
        index_bytes += int(off).to_bytes(2, "little")

    max_w = max(widths) if widths else 0

    # write python module
    with open(out_file, "w", newline="\n") as f:
        f.write("# Autogenerated font file\n")
        f.write("version = '0.1'\n\n")
        f.write(f"def height():\n    return {height}\n\n")
        f.write(f"def max_width():\n    return {max_w}\n\n")
        f.write("def hmap():\n    return True\n\n")
        f.write("def reverse():\n    return False\n\n")
        f.write("def monospaced():\n    return False\n\n")
        f.write(f"def min_ch():\n    return {min_ch}\n\n")
        f.write(f"def max_ch():\n    return {max_ch}\n\n")

        f.write("_font =\\\n")
        dump_bytes_literal(font_bytes, f)
        f.write("\n_index =\\\n")
        dump_bytes_literal(index_bytes, f)

        f.write(f"""
_mvfont = memoryview(_font)

def _chr_addr(ordch):
    offset = 2 * (ordch - min_ch())
    return int.from_bytes(_index[offset:offset + 2], 'little')

def get_ch(ch):
    ordch = ord(ch)
    if not (min_ch() <= ordch <= max_ch()):
        ordch = min_ch()
    offset = _chr_addr(ordch)
    width = int.from_bytes(_font[offset:offset + 2], 'little')
    next_offs = _chr_addr(ordch + 1)
    return _mvfont[offset + 2:next_offs], height(), width
""")

def dump_bytes_literal(bdata: bytes, fh, per_line=16):
    # produce same style as your file: repeated b'...\x..' literals with line-continuation
    hexs = [f"\\x{v:02x}" for v in bdata]
    if not hexs:
        fh.write("b''\n")
        return
    fh.write("b'")
    for i, hx in enumerate(hexs):
        if i and (i % per_line) == 0:
            fh.write("'\\\n b'")
        fh.write(hx)
    fh.write("'\n")


if __name__ == "__main__":
    dump_glyphs("./fonts/CelestiaMediumRedux.ttf", "fonts/celestiavanilla")
    for h in [16, 20, 24]:
        process_glyphs("fonts/celestiavanilla", f"fonts/celestiamarmalade{h}", h)
        encode_font(f"fonts/celestiamarmalade{h}", f"fonts/celestia{h}.py")
